package SoundEngine;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Semaphore;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioFormat;
import javax.swing.JFrame;
import javax.xml.ws.handler.MessageContext.Scope;


import Arduino.LEDVisualizer;
import Arduino.RelayVisuals;
import Common.ColorOutput;
import Common.FeatureList;
import FeatureDetectors.BassFinder;
import FeatureDetectors.ClapFinder;
import FeatureDetectors.FeatureDetector;
import FeatureDetectors.FrequencyRangeFinder;
import FeatureDetectors.LevelMeter;
import FeatureDetectors.SharpClapFinder;
import FeatureDetectors.SilenceFinder;
import FeatureDetectors.VocalsFinder;
import GenreClassifier.NaiveBayesClassifier;
import GenreClassifier.SongFeatureVector;
import LightDJGUI.ColorOutputDisplayer;
import LightDJGUI.ColorOutputDisplayerPanel;
import LightDJGUI.ColorOutputDisplayerTwoLEDs;
import LightDJGUI.LightDJGUI;
import LightDJGUI.ScrollingSpectrum;
import PartyLightsController.PartyLightsController;
import SignalGUI.ChannelLights;
import SignalGUI.ColoredLight;
import SignalGUI.DistributionPlotter;
import SignalGUI.GUIVisualizer;
import SignalGUI.GraphDisplay;
import SignalGUI.RGBLight;
import SignalGUI.RealtimePlotter;
import SignalGUI.ScrollingChannel;
import SignalGUI.TextLight;
import Signals.FFT;
import Signals.FFTEngine;
import Utils.TimerTicToc;
import Visualizors.ColorGenerator;
import Visualizors.CrazyStrobe;
import Visualizors.HueRotator;
import Visualizors.RedBassColoredClapVisualizer;
import Visualizors.VUBass;
import Visualizors.Visualizer;

/**
 * This class is responsible for music visualizations for Steve's LED's.
 * @author Steve Levine
 */
public class VisualizationEngineParty extends VisualizationEngine implements ComponentListener {

	// Visualization stuff
	LightDJGUI gui;
	GraphDisplay graphMapper;
	ScrollingChannel channelMapper;
	ChannelLights lights;
	ColoredLight bassLight;
	RGBLight rgbLight;
	TextLight textLight;
	RealtimePlotter plotter;

	// The list of feature detectors
	protected ArrayList<FeatureDetector> featureDetectors;
	
	// The list of visualizers
	protected ArrayList<Visualizer> visualizers;
	
	
	// The arduino LED visualizer
	LEDVisualizer ledVisuals;
	//PartyLightsController ledVisuals;
	
	TimerTicToc tictoc;
	

	public VisualizationEngineParty(AudioFormat format, double videoDelaySec) {
		super(format, videoDelaySec);
		tictoc = new TimerTicToc();
	}
	
	@Override
	protected void initVisualizations() {

		// Set up the feature detector plugins
		featureDetectors = allFeatureDetectors();
		for(FeatureDetector f : featureDetectors) {
			f.init();
			
			// Get the list of controls requested
			
		}
		
		
		// Set up all of the visualizer plugins
		visualizers = allVisualizers();
		for(Visualizer v : visualizers) {
			v.init();
			
			// Get the list of controls requested
			
		}
		
		
		try {
			ledVisuals = new LEDVisualizer();
			//ledVisuals = new PartyLightsController();
		} catch (Throwable o) {
			System.out.println("WARNING: Couldn't connect to LED's via USB!");
		}
		
		
		
		// Set up the GUI
		startGUI();
		
	}
	
	/**
	 * Return the comprehensive list of all FeatureDetectors. Must be added here to show up in the LightDJ GUI.
	 * @return
	 */
	public ArrayList<FeatureDetector> allFeatureDetectors() {
		ArrayList<FeatureDetector> detectors = new ArrayList<FeatureDetector>();
		
		int FFT_SIZE = BUFFER_SIZE;
		double UPDATES_PER_SECOND = 1.0 * SAMPLE_RATE / FFT_SIZE * BUFFER_OVERLAP; 
		
		// Add the detectors here
		detectors.add(new BassFinder(FFT_SIZE, UPDATES_PER_SECOND));
		detectors.add(new ClapFinder(FFT_SIZE, UPDATES_PER_SECOND));
		detectors.add(new FrequencyRangeFinder(FFT_SIZE, UPDATES_PER_SECOND));
		detectors.add(new LevelMeter(FFT_SIZE, UPDATES_PER_SECOND));
		
		
		// Return them all
		return detectors;
		
	}
	
	/**
	 * Return the comprehensive list of all FeatureDetectors. Must be added here to show up in the LightDJ GUI.
	 * @return
	 */
	public ArrayList<Visualizer> allVisualizers() {
		ArrayList<Visualizer> visualizers = new ArrayList<Visualizer>();
		
		int FFT_SIZE = BUFFER_SIZE;
		double UPDATES_PER_SECOND = 1.0 * SAMPLE_RATE / FFT_SIZE * BUFFER_OVERLAP; 
		
		// Add the detectors here
		visualizers.add(new RedBassColoredClapVisualizer(FFT_SIZE, UPDATES_PER_SECOND));
		visualizers.add(new VUBass(FFT_SIZE, UPDATES_PER_SECOND));
		//visualizers.add(new CrazyStrobe(FFT_SIZE, UPDATES_PER_SECOND));
		
		return visualizers;
		
	}

	
	
	@Override
	protected RenderFrame computeVisualsRendering(FFT fft) {
		
		// Create a featurelist, and pass it along with the FFT to each FeatureDetector
		FeatureList featureList = new FeatureList();
		double[] frequencies = fft.getFrequencies();
		double[] magnitudes = fft.getMagnitudes();
		
		// Compute all of the features
		for(FeatureDetector f : featureDetectors) {
			f.computeFeatures(frequencies, magnitudes, featureList);
		}
		
		// Now that we have a full-fledged FeatureList, pass it to the Visualizers
		ColorOutput[] colorOutputs = new ColorOutput[visualizers.size()];
		for(int i = 0; i < visualizers.size(); i++) {
			Visualizer v = visualizers.get(i);
			ColorOutput c = v.visualize(featureList);
			colorOutputs[i] = c;
		}
		
		
		RenderFrameParty renderFrame = new RenderFrameParty();
		renderFrame.colorOutputs = colorOutputs;
		
		
		
		//plotter.update(new double[] {100.0*((Double) featureList.getFeature("BASS_RAW")), 0.0});
		
		
		//plotter.render();
		spectrumMapper.updateWithNewSpectrum(frequencies, magnitudes);
		
		
		return renderFrame;
	}

	@Override
	protected void renderVisuals(RenderFrame rf) {
		
		RenderFrameParty renderFrame = (RenderFrameParty) rf;

		
		
		// Update LED lights
		//System.out.println(renderFrame.colorOutputs[0].rgbLights[0]);
		
		//ledVisuals.visualize(mixColors(renderFrame));	// Send SERIAL to the RGB's
		
		//bassLight.update(renderFrame.colorOutputs[0].rgbLights[0].getRed() / 255.0);
		//rgbLight.update(renderFrame.colorOutputs[0].rgbLights[1]);
		// channelMapper.updateWithNewChannelColors(new Color[]{bassLight.getCurrentColor(), rgbLight.getCurrentColor()});	// Update the scrolling "rock band" display
		// plotter.render();
		
		
		// Store the last frame so that it can be rendered appropriately!
		synchronized(this) {
			lastFrame = renderFrame;
		}
	
	}
	
	/**
	 * Takes in the current color frame to be rendered. Retrieves the current cross-fade mixing
	 * parameter from the LightingDJ GUI, and mixes the appropriate ColorOutputs together to yield
	 * one color output.
	 */
	protected ColorOutput mixColors(RenderFrameParty rf) {
		
		// For now, just return the first.
		return rf.colorOutputs[0];
		
		
	}
	

	/**
	 * TODO
	 * TODO
	 * TODO
	 * 
	 * The following methods and fields are all for the LightDJ GUI!
	 * 
	 * TODO
	 * TODO
	 * TODO
	 */
	// Graphics and GUI-related variables
	protected final static int SIDEBAR_WIDTH = 350;
	protected final static int SPECTRUM_WIDTH = 900;
	protected final static int SPECTRUM_HEIGHT = 200;
	protected final static int BORDER_SIZE = 10;
	protected final static int LIGHTBAR_HEIGHT = 200;
	protected final static int RECORD_CONTROLS_WIDTH = 500;
	protected final static int RECORD_CONTROLS_HEIGHT = 400;
	protected final static int RECORD_WIDTH = 400;
	protected final static int RECORDS_WIDTH = 2*RECORD_CONTROLS_WIDTH + BORDER_SIZE;
	protected static int ACTIVE_LAYER_X = 9*BORDER_SIZE;
	protected static int ACTIVE_LAYER_Y = 9*BORDER_SIZE;
	protected static int ACTIVE_LAYER_WIDTH;
	protected static int ACTIVE_LAYER_HEIGHT;
	protected static int RECORD_BOX_LEFT_X;
	protected static int RECORD_BOX_LEFT_Y;
	protected static int RECORD_BOX_RIGHT_X;
	protected static int RECORD_BOX_RIGHT_Y;
	
	// Some color information
	protected static Color PANEL_BACKGROUND_COLOR;
	protected static Color PANEL_BORDER_COLOR;
	protected static Color TEXT_COLOR;
	protected static AlphaComposite COMPOSITE_TRANSLUCENT;
	protected static AlphaComposite COMPOSITE_OPAQUE;
	
	// Render buffers
	protected BufferedImage background;
	protected BufferedImage buffer;
	
	// Preloaded images
	protected BufferedImage turntableLogo;
	protected BufferedImage recordLeft;
	protected BufferedImage recordRight;
	
	// Controls and displays
	protected ScrollingSpectrum spectrumMapper;
	protected RenderFrameParty lastFrame;
	protected ColorOutputDisplayer colorOutputDisplayer;
	
	// Whether or not to draw a layer above everything else, for fine-tuned control
	protected boolean activeLayer = true;
	
	// Which visualizers are currently being used
	protected static int visualizerLeftIndex = 0;
	protected static int visualizerRightIndex = 1;
	
	
	public void startGUI() {
		gui = new LightDJGUI(this);
		JFrame frame = new JFrame("Light DJ");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.add(gui);
		frame.pack();
		gui.setBackground(Color.BLACK);
		frame.setSize(1500, 1000);
		frame.setVisible(true);
		frame.addComponentListener(this);
		
		// Set some colors
		PANEL_BACKGROUND_COLOR = new Color(10, 10, 10);
		PANEL_BORDER_COLOR = new Color(30, 30, 30);
		COMPOSITE_OPAQUE = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);
		COMPOSITE_TRANSLUCENT = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.9f);
		
		// Set up some other GUI elements
		spectrumMapper = new ScrollingSpectrum(0, 0, SPECTRUM_WIDTH, SPECTRUM_HEIGHT, null, 30, 20000, 100.0, BUFFER_SIZE, SAMPLE_RATE);
		
		// Choose which color output displayer to use!
		colorOutputDisplayer = new ColorOutputDisplayerPanel();
		
		// Generate the background
		generateBackground();
	
		
		// Start a tast to render regularly!
		Timer t = new Timer();
		t.scheduleAtFixedRate(new RenderTask(this), 0, 50);
		
		System.out.println("Light DJ started.");
	}
	
	
	/**
	 * Generate a pretty looking background image
	 */
	private void generateBackground() {
		// Allocate an image of the proper size
		int width = gui.getWidth();
		int height = gui.getHeight();
		background = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		buffer = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics2D g2D = (Graphics2D) background.getGraphics();
		
		// Redefine some geometric parameters
		RECORD_BOX_LEFT_X = SIDEBAR_WIDTH + (width - RECORDS_WIDTH - SIDEBAR_WIDTH) / 2 + BORDER_SIZE;
		RECORD_BOX_LEFT_Y = BORDER_SIZE*2 + LIGHTBAR_HEIGHT;
		RECORD_BOX_RIGHT_X = SIDEBAR_WIDTH + (width - RECORDS_WIDTH - SIDEBAR_WIDTH) / 2 + BORDER_SIZE*2 + RECORD_CONTROLS_WIDTH;
		RECORD_BOX_RIGHT_Y =  BORDER_SIZE*2 + LIGHTBAR_HEIGHT;
		
		ACTIVE_LAYER_WIDTH = width - 18*BORDER_SIZE;
		ACTIVE_LAYER_HEIGHT = height - 18*BORDER_SIZE;
		
		
		// Paint a black background
		g2D.setBackground(Color.BLACK);
		g2D.clearRect(0, 0, width, height);
		
		
		// Display the turntable image, loading it if necessary.
		if (turntableLogo == null) {
			// Try and load it
			try {
				turntableLogo = ImageIO.read(new File("Images/background.png"));
				recordLeft = ImageIO.read(new File("Images/record_left.png"));
				recordRight = ImageIO.read(new File("Images/record_right.png"));
			} catch (IOException e) {
				System.out.println("Warning: Could not load LightDJ background image!");
				e.printStackTrace();
				return;
			}
		}
		g2D.drawImage(turntableLogo, SIDEBAR_WIDTH, 0, null);
		
		// Draw the sidebar
		//g2D.setColor(new Color(10,10,10));
		//g2D.fillRect(0, 0, SIDEBAR_WIDTH, height);
		g2D.setColor(PANEL_BORDER_COLOR);
		g2D.drawLine(SIDEBAR_WIDTH, 0, SIDEBAR_WIDTH, height);
		

		g2D.drawImage(recordLeft, RECORD_BOX_LEFT_X + (RECORD_CONTROLS_WIDTH - RECORD_WIDTH) /2, RECORD_BOX_LEFT_Y + RECORD_CONTROLS_HEIGHT, null);
		g2D.drawImage(recordRight, RECORD_BOX_RIGHT_X + (RECORD_CONTROLS_WIDTH - RECORD_WIDTH) /2, RECORD_BOX_RIGHT_Y + RECORD_CONTROLS_HEIGHT, null);
		
		g2D.setColor(PANEL_BACKGROUND_COLOR);
		g2D.fillRoundRect(RECORD_BOX_LEFT_X, RECORD_BOX_LEFT_Y, RECORD_CONTROLS_WIDTH, RECORD_CONTROLS_HEIGHT, 40, 40);
		g2D.fillRoundRect(RECORD_BOX_RIGHT_X, RECORD_BOX_RIGHT_Y, RECORD_CONTROLS_WIDTH, RECORD_CONTROLS_HEIGHT, 40, 40);
		g2D.setColor(PANEL_BORDER_COLOR);
		g2D.drawRoundRect(RECORD_BOX_LEFT_X, RECORD_BOX_LEFT_Y, RECORD_CONTROLS_WIDTH, RECORD_CONTROLS_HEIGHT, 40, 40);
		g2D.drawRoundRect(RECORD_BOX_RIGHT_X, RECORD_BOX_RIGHT_Y, RECORD_CONTROLS_WIDTH, RECORD_CONTROLS_HEIGHT, 40, 40);
		
		// Render the visualizer plugins
		loadVisualizerPlugin(true, visualizerLeftIndex);
		loadVisualizerPlugin(false, visualizerRightIndex);
		
		// Resize where the scrolling spectrum goes
		//spectrumMapper.move(SIDEBAR_WIDTH + BORDER_SIZE, gui.getHeight() - SPECTRUM_HEIGHT - BORDER_SIZE , gui.getWidth() - SIDEBAR_WIDTH - 2*BORDER_SIZE, SPECTRUM_HEIGHT);
		spectrumMapper.move(BORDER_SIZE, gui.getHeight() - SPECTRUM_HEIGHT - BORDER_SIZE , SIDEBAR_WIDTH - 2*BORDER_SIZE, SPECTRUM_HEIGHT);
		spectrumMapper.setGraphics((Graphics2D) background.getGraphics());
		
	}
	
	/**
	 * Draws everything for the visualizer plugin
	 */
	private void loadVisualizerPlugin(boolean left, int pluginIndex) {
		Visualizer visualizer = visualizers.get(pluginIndex);
		
		int x; int y; int width; int height;
		if (left) {
			x = RECORD_BOX_LEFT_X + BORDER_SIZE;
			y = RECORD_BOX_LEFT_Y + BORDER_SIZE;
			width = RECORD_CONTROLS_WIDTH - 2*BORDER_SIZE;
			height = RECORD_CONTROLS_HEIGHT - 2*BORDER_SIZE;
		} else {
			x = RECORD_BOX_RIGHT_X + BORDER_SIZE;
			y = RECORD_BOX_RIGHT_Y + BORDER_SIZE;
			width = RECORD_CONTROLS_WIDTH - 2*BORDER_SIZE;
			height = RECORD_CONTROLS_HEIGHT - 2*BORDER_SIZE;
		}
		
		Graphics2D g2D = (Graphics2D) background.getGraphics();
		g2D.setColor(Color.WHITE);
		g2D.drawString(visualizer.getName(), x, y);
		
		
		
	}
	
	
	/**
	 * Render the Light DJ GUI 
	 * (Called automagically by a timer)
	 */
	public void renderDJ() {
		RenderFrameParty renderFrame;
		synchronized(this) {
			renderFrame = lastFrame;
		}
		
		if (renderFrame == null) {
			// Don't render!
			return;
		}
		
		Graphics2D g2D = (Graphics2D) background.getGraphics();
		int width = gui.getWidth();
		int height = gui.getHeight();
		
		// Compute the mixed colors
		ColorOutput mixedColors = mixColors(renderFrame); 
			
		spectrumMapper.render();
		colorOutputDisplayer.render(mixedColors, g2D, SIDEBAR_WIDTH + BORDER_SIZE, BORDER_SIZE, gui.getWidth() - SIDEBAR_WIDTH - 2*BORDER_SIZE, LIGHTBAR_HEIGHT);

		
		Graphics2D g2DGui = (Graphics2D) gui.getGraphics();
		Graphics2D g2DBuf = (Graphics2D) buffer.getGraphics();
		
		
		activeLayer = false;
		
		if (activeLayer) {
			g2DBuf.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));
			g2DBuf.drawImage(background, 0, 0, null);
			
			g2DBuf.setColor(PANEL_BACKGROUND_COLOR);
			g2DBuf.setComposite(COMPOSITE_TRANSLUCENT);
			g2DBuf.fillRoundRect(ACTIVE_LAYER_X, ACTIVE_LAYER_Y - BORDER_SIZE, ACTIVE_LAYER_WIDTH, ACTIVE_LAYER_HEIGHT, 50, 50);
			g2DBuf.setComposite(COMPOSITE_OPAQUE);
			
			g2DBuf.setColor(PANEL_BORDER_COLOR);
			g2DBuf.drawRoundRect(ACTIVE_LAYER_X, ACTIVE_LAYER_Y - BORDER_SIZE, ACTIVE_LAYER_WIDTH, ACTIVE_LAYER_HEIGHT, 50, 50);
			
			g2DGui.drawImage(buffer, 0, 0, null);
		
		} else {
			
			g2DGui.drawImage(background, 0, 0, null);
		}
		
	}
	
	
	
	
	public void paintDJ(Graphics g) {
		// Repaint the background
		Graphics2D g2D = (Graphics2D) g;
		g2D.drawImage(background, 0, 0, null);
		
	}
	public void componentHidden(ComponentEvent e) {}
	public void componentMoved(ComponentEvent e) {}
	public void componentShown(ComponentEvent e) {}
	public void componentResized(ComponentEvent e) {generateBackground();}

	
	
	
	
	
}


class RenderFrameParty extends RenderFrame {

	ColorOutput[] colorOutputs;
	
}

class RenderTask extends TimerTask {
	private VisualizationEngineParty engine;
	public RenderTask(VisualizationEngineParty eng) {engine = eng;}
	public void run() {
		try {
			engine.renderDJ();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
}
