package VIsualServo;

import VisualServo.Image.Pixel;
/**
 * BlobTracking performs image processing and tracking for the VisualServo
 * module.  BlobTracking filters raw pixels from an image and classifies blobs,
 * generating a higher-level vision image.
 *
 * @author previous TA's, prentice
 */
public class BlobTracking {

	protected int stepCounter = 0;
	protected double lastStepTime = 0.0;

	public int width;
	public int height;
	public int numChannels = 3;


	// Variables used for velocity controller that are available to calling
	// process.  Visual results are valid only if targetDetected==true; motor
	// velocities should do something sane in this case.
	public boolean targetDetected = false; // set in blobPresent()
	public double centroidX = 0.0; // set in blobPresent()
	public double centroidY = 0.0; // set in blobPresent()
	public double targetArea = 0.0; // set in blobPresent()
	public double targetRange = 0.0; // set in blobFix()
	public double targetBearing = 0.0; // set in blobFix()

	//variables used to specify the desired parameters of the object 
	//these are set to different values for every object 

	public double hue_range = 0.1;
	public double hue_mean = 0.38;
	public double hue_min = hue_mean - hue_range/2.0; 
	public double hue_max = hue_mean + hue_range/2.0;
	public double sat_min=0; 
	public double sat_max=1; 
	public double bright_min=.25; 
	public double bright_max=1; 

	//set for a green ball
	public int desired_red=0; 
	public int desired_green=255; 
	public int desired_blue=0; 



	/**
	 * <p>Create a BlobTracking object</p>
	 *
	 * @param image width
	 * @param image height
	 */
	public BlobTracking(int width, int height) {

		this.width = width;
		this.height = height;

	}


	/**
	 * <p>Computes frame rate of vision processing</p>
	 */
	private void stepTiming() {
		double currTime = System.currentTimeMillis();
		stepCounter++;
		// if it's been a second, compute frames-per-second
		if (currTime - lastStepTime > 1000.0) {
			double fps = (double) stepCounter * 1000.0
			/ (currTime - lastStepTime);
			System.err.println("FPS: " + fps);
			stepCounter = 0;
			lastStepTime = currTime;
		}
	}



	/**
	 * <p>Highlight the blob in the given image, while setting all
	 * background pixels to grayscale<\p>
	 *
	 * @param source image
	 * @param destination image
	 */
	public void BlobPixel(Image source, Image destination)
	{
		//System.out.println("Blob pixel entered"); 

		for(int x=0; x < width; x++)
		{

			for(int y=0; y < height; y++ )
			{
				Pixel current_pixel=source.getPixel(x,y); 
				if(targetClassify(current_pixel))
				{
					destination.setPixel(x,y,new Pixel(desired_red, desired_green, desired_blue)); 
				}
				else
				{
					int luminence=(current_pixel.getRed() + current_pixel.getRed()+ current_pixel.getBlue())/3; 
					destination.setPixel(x,y,new Pixel(luminence,luminence,luminence)); 
				}

			}
		}

	}

	public boolean targetClassify(Pixel pixel)
	{
		if ( (hue_min <= pixel.getHue()) && (hue_max >= pixel.getHue()) && (sat_min <= pixel.getSaturation()) && (sat_max >= pixel.getSaturation()) && (bright_min <= pixel.getBrightness()) && (bright_max >= pixel.getBrightness()))
			return true; 
		else
			return false; 
	}


	/**
	 * <p>Segment out a blob from the src image (if a good candidate exists).</p>
	 *
	 * <p><code>dest</code> is a packed RGB image for a java image drawing
	 * routine. If it's not null, the blob is highlighted.</p>
	 *
	 * @param src the source RGB image, not packed
	 * @param dest the destination RGB image, packed, may be null
	 */
	public void apply(Image src, Image dest) {

		stepTiming();  // monitors the frame rate
		//System.out.println("Apply");

		/*
		//Print out pixel information for a 
	
		*/
		int width = src.getWidth();
		int height = src.getHeight();

		// Copy over the image
		for(int y = 0; y < height; y++) {
			for(int x = 0; x < width; x++) {
				Pixel pix = src.getPixel(x, y);
				dest.setPixel(x, y, new Pixel(pix.getRed(), pix.getGreen(), pix.getBlue()));
			}
		}



		int box_size = (int) (0.25 * width);
		int box_left = (int) ((width - box_size) / 2);
		int box_top = (int) ((height - box_size) / 2);



		// Compute an average over RGB
		double sum_R = 0.0;
		double sum_G = 0.0;
		double sum_B = 0.0;
		for(int x = box_left; x < box_left + box_size; x++) {
			for (int y = box_top; y < box_top + box_size; y++) {
				Pixel p = src.getPixel(x, y);
				//sum_R += p.getRed();
				//sum_G += p.getGreen();
				//sum_B += p.getBlue();
				sum_R += p.getHue();
				sum_G += p.getSaturation();
				sum_B += p.getBrightness();	
			}
		}

		double average_R = sum_R / (box_size * box_size);
		double average_G = sum_G / (box_size * box_size);
		double average_B = sum_B / (box_size * box_size);

		System.out.println("Average: H = " + average_R + ", S = " + average_G + ", B = " + average_B + ", size = " + box_size);

		// Print out the 4 corner values for fun!
		int corner = 0;
		for (int x = box_left; x <= box_left + box_size; x += box_size) {
			for(int y = box_top; y <= box_top + box_size; y += box_size) {
				Pixel p = src.getPixel(x, y);				
		//		System.out.println("Corner " + corner + " R = " + p.getRed() + ", G = " + p.getGreen() + ", B = " + p.getBlue());
				corner++;
			}
		}


		// Overlay histogram
		//Image blobbed = new Image(src); 		
		BlobPixel(src, dest);
		blobPresent(dest,dest); 
		Histogram.getHistogram(src, dest, true);
		blobFix();
		// End Student Code
	}

	public void blobPresent(Image src, Image dest) {
		// Copy src to dest
		//System.out.println("blobPresent method entered"); 
		// Change these values to tune the system
		int blobGain = 10; // minimum number of pixels that has to be on all four edges of a ball
		int blobDetectionGain = 90; // minimum number of pixels to declare a ball is present.


		// Pixel count for each RGB colored pixel
		int redPixelCount = 0;
		int greenPixelCount = 0;
		int bluePixelCount = 0;

		// X and Y ranges for ball
		int xLow = -1;
		int xHigh = -1;
		int yLow = -1;
		int yHigh = -1;

		// Takes in picture of pixels classifed in red, blue, green, or grey

		// Counts number of pixels per RGB color
		//System.out.println("image width :" + src.getWidth()); 
		//System.out.println("image height :" + src.getHeight()); 
		for (int x1 = 0; x1 < src.getWidth(); x1++){
			//System.out.println("x for loop entered: " + x1);

			for (int y = 0; y < src.getHeight(); y++){
				//System.out.println("y for loop entered: "+y);
				Pixel suspect = src.getPixel(x1,y);

				//  System.out.println("pixel made"); 
				if(suspect.getRed() ==255){
					redPixelCount++;
					//   System.out.println("increment red"); 
				} else if(suspect.getGreen() == 255){
					greenPixelCount++;
					// System.out.println("Increment green"); 
				} else if(suspect.getBlue() == 255){
					bluePixelCount++;
					//System.out.println("increment blue"); 
				}

			}
		}
		//System.out.println("red "+redPixelCount + " green :"+greenPixelCount +" blue :"+bluePixelCount); 

		// Choose which color has the most pixels on the screen
		// Find greatest number of the 3
		int maxPixelCount = Math.max(redPixelCount, greenPixelCount);
		maxPixelCount = Math.max(maxPixelCount, bluePixelCount);

		System.out.println("maxPixelCount: " + maxPixelCount);

		// Create array of the pixel counts in the x and y planes
		int [] x_PixelCount = new int[src.getWidth()+1];
		int [] y_PixelCount = new int[src.getHeight()+1];
		// Set all values to 0
		for (int x = 0; x < src.getWidth(); x++){
			x_PixelCount[x] = 0;
		}
		for (int y = 0; y < src.getHeight(); y++){
			y_PixelCount[y] = 0;
		}
		//System.out.println("arrays created");

		// Begin tallying all the pixels
		for (int x = 0; x < src.getWidth(); x++){
			//System.out.println("entered x-loop: " + x);
			for (int y = 0; y < src.getHeight(); y++){
				//System.out.println("entered y-loop: " + y);
				Pixel suspect = src.getPixel(x,y);
				if (suspect.getRed() == 255 && redPixelCount == maxPixelCount){
					x_PixelCount[x] = x_PixelCount[x] + 1;
					y_PixelCount[y] = y_PixelCount[y] + 1;
				}else if(suspect.getGreen() == 255 && greenPixelCount == maxPixelCount){
					x_PixelCount[x] = x_PixelCount[x] + 1;
					y_PixelCount[y] = y_PixelCount[y] + 1;
				}else if(suspect.getBlue() == 255 && bluePixelCount == maxPixelCount){
					x_PixelCount[x] = x_PixelCount[x] + 1;
					y_PixelCount[y] = y_PixelCount[y] + 1;
				}

			}
		}

		
		// Determine if there is a ball in view
		if(maxPixelCount > blobDetectionGain){
		targetDetected = true;
		}
		else{
		targetDetected = false;
		return;
		}

		//System.out.println("start finding bounds of blob");
		// Find xLow       
		for (int x = 0; x < src.getWidth()-1; x++){
			if(x_PixelCount[x] >= blobGain ){
				xLow = x;
				break;
			}
		}

		// Find xHigh
		for (int x = src.getWidth()-1; x > 0 ; x--){
			if(x_PixelCount[x] >= blobGain ){
				xHigh = x;
				break;
			}
		}

		// Find yLow
		for (int y = 0; y < src.getHeight()-1; y++){
			if(y_PixelCount[y] >= blobGain ){
				yLow = y;
				break;
			}
		}

		// Find yHigh
		for (int y = src.getHeight()-1; y > 0 ; y--){
			if(y_PixelCount[y] >= blobGain ){
				yHigh = y;
				break;
			}
		}

		if (xLow == -1 ||xHigh == -1 || yLow == -1 || yHigh == -1)//couldn't find an edge
		{
			targetDetected = false;
			return;
		}

		// Compute ball area
		targetArea = maxPixelCount;

		// Compute ball center
		centroidX = (xHigh + xLow)/2.0;
		centroidY = (yHigh + yLow)/2.0;

		// Draw in box arround ball, where the edge is the diameter of the ball
		Pixel blackPixel = new Pixel(255,255,255);
		for (int x = xLow; x <= xHigh; x++){
			dest.setPixel(x, yLow, blackPixel);
			dest.setPixel(x, yHigh, blackPixel);
		}
		for (int y = yLow; y <= yHigh; y++){
			dest.setPixel(xLow, y, blackPixel);
			dest.setPixel(xHigh, y, blackPixel);
		}

		// Draw in 'x' at center
		System.out.println("xLow: " + xLow + " xHigh: " + xHigh + " yLow: "+yLow+" yHigh: " + yHigh);
		System.out.println("height " + src.getHeight() + " width: " + src.getWidth());	
		
		for (int x = (int)centroidX - 3; x <= centroidX + 3; x++){
			if (x < 0) x = 0;
			else if (x>=src.getWidth()) x = src.getWidth()-1;
			//System.out.print(" x: " + x);
			dest.setPixel(x, (int)centroidY, blackPixel);

		}
		for (int y = (int)centroidY - 3; y <= centroidY + 3; y++){
			if (y< 0) y = 0;
			else if (y>=src.getHeight()) y = src.getHeight()-1;
			//System.out.print(" y: " + y);
			dest.setPixel((int)centroidX, y, blackPixel);
		}

	}
	
	public void blobFix()	{
		//set targetRange, targetBearing
		//calibration for range, bearing: cal/area=dist, (centroidX-width/2)*cal=bearing
		double range_calib=14.0;	//units = meters^3
		double bearing_calib=.005740; //units = rad/meter
		
		targetRange=range_calib/Math.sqrt(targetArea); //units = meters
		targetBearing=bearing_calib*(width/2-centroidX); //units = radians, object to the right is positive
		System.out.println("Area = " + targetArea + ", CentroidX = " + centroidX + ", width/2 = "+ width/2);
	}

}
